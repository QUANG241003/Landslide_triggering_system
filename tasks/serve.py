import subprocess
import threading
import grpc
from concurrent import futures

# These files are generated by the protobuf compiler
from protos.order_pb2_grpc import PingServiceServicer, add_PingServiceServicer_to_server
from protos.order_pb2 import PingResponse, ExeResult
# Executing tasks
# from ingestion_script.crawling import Crawler


class Server(PingServiceServicer):
    def __init__(self, *args, **kwargs):
        # super().__init__(*args, **kwargs)
        # self.extract_csv_thread = threading.Thread(target=self.extract_csv)
        # self.extract_xlsx_thread = threading.Thread(target=self.extract_xlsx)
        # self.crawl_csv_thread = threading.Thread(target=self.crawl_csv)
        # self.crawl_xlsx_thread = threading.Thread(target=self.crawl_xlsx)
        # self.import_csv_thread = threading.Thread(target=self.import_csv)
        # self.import_xlsx_thread = threading.Thread(target=self.import_xlsx)
        pass

    def ping(self, request, context):
        print('pong')
        result = {'message': 'pong'}
        return PingResponse(**result)
    
    def command(self, request, context):
        print('received command: ' + request.command)
        result = {'message': 'received command: ' + request.command}
        if request.command == 'extract_csv':
            # self.extract_csv_thread.start()
            with open('/app/logs/extracter_logs.log', 'a') as log_file:  # Open log file in append mode
                subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/extraction.py', '--source', 'csv'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'extracting csv'}
        elif request.command == 'extract_xlsx':
            # self.extract_xlsx_thread.start()
            with open('/app/logs/extracter_logs.log', 'a') as log_file:
                subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/extraction.py', '--source', 'xlsx'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'extracting xlsx'}
        elif request.command == 'crawl_csv':
            # self.crawl_csv_thread.start()
            with open('/app/logs/crawler_logs.log', 'a') as log_file:
                process = subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/crawling.py', '--source', 'csv'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'crawling csv'}
        elif request.command == 'crawl_xlsx':
            # self.crawl_xlsx_thread.start()
            with open('/app/logs/crawler_logs.log', 'a') as log_file:
                subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/crawling.py', '--source', 'xlsx'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'crawling xlsx'}
        elif request.command == 'import_csv':
            with open('/app/logs/importer_logs.log', 'a') as log_file:
                # self.import_csv_thread.start()
                subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/importing.py','--source', 'csv'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'importing csv'}
        elif request.command == 'import_xlsx':
            with open('/app/logs/importer_logs.log', 'a') as log_file:
                subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/importing.py', '--source', 'xlsx'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
            result = {'message': 'importing xlsx'}
        return ExeResult(**result)
        
    
    # Extracting threads
    # def extract_csv(self):
    #     with open('/app/logs/extracter_logs.log', 'a') as log_file:  # Open log file in append mode
    #         subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/extraction.py', '--source', 'csv'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
    #     pass
    # def extract_xlsx(self):
    #     with open('/app/logs/extracter_logs.log', 'a') as log_file:
    #         subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/extraction.py', '--source', 'xlsx'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
    #     pass
    # # Crawling threads
    # def crawl_csv(self):
    #     if self.extract_csv_thread.is_alive():
    #         self.extract_csv_thread.join()
    #     with open('/app/logs/crawler_logs.log', 'a') as log_file:
    #         subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/crawling.py', '--source', 'csv'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
    #     # subprocess.run(['rm', '/app/buffer/date_csv.json'], check=True)
    # def crawl_xlsx(self):
    #     if self.extract_xlsx_thread.is_alive():
    #         self.extract_xlsx_thread.join()
    #     with open('/app/logs/crawler_logs.log', 'a') as log_file:
    #         subprocess.run(['conda', 'run', '-n', 'landslide_ingestion', 'python', '/app/tasks/ingestion_script/crawling.py', '--source', 'xlsx'], check=True, stdout=log_file, stderr=subprocess.STDOUT)
    #     # subprocess.run(['rm', '/app/buffer/date_xlsx.json'], check=True)
    # # Importing threads
    # def import_csv(self):
    #     if self.crawl_csv_thread.is_alive():
    #         self.crawl_csv_thread.join()
    #     subprocess.run(['touch', "/app/buffer/import_csv.json"])
    #     pass
    # def import_xlsx(self):
    #     if self.crawl_xlsx_thread.is_alive():
    #         self.crawl_xlsx_thread.join()
    #     subprocess.run(['touch',"/app/buffer/import_xlsx.json"])
    #     pass
    

def serve():
    server = grpc.server(futures.ThreadPoolExecutor(max_workers=20))
    add_PingServiceServicer_to_server(Server(), server)
    server.add_insecure_port('[::]:3170')
    server.start()
    print('gRPC ping server started on localhost:3170')
    print('listening ...')
    server.wait_for_termination()


if __name__ == '__main__':
    serve()